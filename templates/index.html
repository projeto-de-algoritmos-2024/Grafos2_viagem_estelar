<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visualização de Grafo</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/FontLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/fonts/helvetiker_regular.typeface.json"></script>
    <script>
        // Configurar a cena, câmera e renderizador
        const cena = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderizador = new THREE.WebGLRenderer();
        renderizador.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderizador.domElement);

        // Adicionar controles de órbita
        const controles = new THREE.OrbitControls(camera, renderizador.domElement);
        camera.position.z = 100;

        // Adicionar um fundo de campo de estrelas
        const geometriaEstrelas = new THREE.BufferGeometry();
        const materialEstrelas = new THREE.PointsMaterial({ color: 0xffffff });
        const verticesEstrelas = [];
        for (let i = 0; i < 10000; i++) {
            verticesEstrelas.push((Math.random() - 0.5) * 2000);
            verticesEstrelas.push((Math.random() - 0.5) * 2000);
            verticesEstrelas.push((Math.random() - 0.5) * 2000);
        }
        geometriaEstrelas.setAttribute('position', new THREE.Float32BufferAttribute(verticesEstrelas, 3));
        const estrelas = new THREE.Points(geometriaEstrelas, materialEstrelas);
        cena.add(estrelas);

        // Função para adicionar nós e arestas à cena
        const malhasNos = {};
        const linhasArestas = {};
        const etiquetasArestas = {};  // Armazenar etiquetas de arestas aqui
        const etiquetasNos = {};  // Armazenar etiquetas de nós aqui
        let nosSelecionados = [];

        // Raycaster e vetor do mouse
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        function adicionarDadosGrafo(nos, arestas) {
            const materialNoEstrela = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            const materialNoConstelacao = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
            const geometriaNo = new THREE.SphereGeometry(1, 32, 32);

            // Carregar fonte
            const carregador = new THREE.FontLoader();
            carregador.load('https://cdn.jsdelivr.net/npm/three@0.128.0/examples/fonts/helvetiker_regular.typeface.json', function (fonte) {
                // Adicionar nós
                nos.forEach(no => {
                    const malhaNo = new THREE.Mesh(geometriaNo, no.type === 'estrela' ? materialNoEstrela : materialNoConstelacao);
                    malhaNo.position.set(Math.random() * 100 - 50, Math.random() * 100 - 50, Math.random() * 100 - 50);
                    malhaNo.userData = { id: no.id, type: no.type };

                    // Adicionar etiqueta para estrelas e constelações
                    const etiqueta = criarEtiqueta(no.id, fonte);
                    etiqueta.position.copy(malhaNo.position);
                    cena.add(etiqueta);
                    etiquetasNos[no.id] = etiqueta;

                    malhasNos[no.id] = malhaNo;
                    cena.add(malhaNo);
                });

                // Adicionar arestas
                const materialAresta = new THREE.LineBasicMaterial({ color: 0xffffff });
                arestas.forEach(aresta => {
                    const geometriaAresta = new THREE.BufferGeometry().setFromPoints([
                        malhasNos[aresta.source].position,
                        malhasNos[aresta.target].position
                    ]);
                    const linhaAresta = new THREE.Line(geometriaAresta, materialAresta);
                    linhasArestas[`${aresta.source}-${aresta.target}`] = linhaAresta;
                    cena.add(linhaAresta);
                    
                    // Criar e adicionar etiqueta de aresta
                    const etiquetaAresta = criarEtiqueta(aresta.distance.toFixed(2) + ' anos-luz', fonte);
                    etiquetaAresta.position.copy(new THREE.Vector3().addVectors(malhasNos[aresta.source].position, malhasNos[aresta.target].position).divideScalar(2));
                    cena.add(etiquetaAresta);
                    etiquetasArestas[`${aresta.source}-${aresta.target}`] = etiquetaAresta;
                });
            });
        }

        function criarEtiqueta(texto, fonte) {
            const geometria = new THREE.TextGeometry(texto, {
                font: fonte,
                size: 2,
                height: 1.0
            });
            const material = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const malhaEtiqueta = new THREE.Mesh(geometria, material);

            // Ajuste a posição do malhaEtiqueta conforme necessário
            return malhaEtiqueta;
        }

        function encontrarCaminhoMaisCurto(origem, destino) {
            fetch('/shortest-path', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ source: origem, target: destino })
            })
            .then(response => response.json())
            .then(data => {
                if (data.error) {
                    console.error(data.error);
                    return;
                }

                // Ocultar todos os nós e arestas
                Object.keys(malhasNos).forEach(idNo => {
                    const malhaNo = malhasNos[idNo];
                    malhaNo.visible = false; // Ocultar todos os nós
                });
                Object.keys(linhasArestas).forEach(chaveAresta => {
                    const linhaAresta = linhasArestas[chaveAresta];
                    linhaAresta.visible = false; // Ocultar todas as arestas
                    const etiquetaAresta = etiquetasArestas[chaveAresta];
                    if (etiquetaAresta) {
                        etiquetaAresta.visible = false; // Ocultar todas as etiquetas de arestas
                    }
                });

                // Mostrar apenas nós e arestas no caminho
                const arestasCaminho = new Set();
                const nosCaminho = new Set();

                data.path_edges.forEach(([origem, destino]) => {
                    arestasCaminho.add(`${origem}-${destino}`);
                    arestasCaminho.add(`${destino}-${origem}`);
                    nosCaminho.add(origem);
                    nosCaminho.add(destino);

                    if (malhasNos[origem]) {
                        malhasNos[origem].visible = true; // Mostrar nós no caminho
                    }
                    if (malhasNos[destino]) {
                        malhasNos[destino].visible = true; // Mostrar nós no caminho
                    }
                    const geometriaCaminho = new THREE.BufferGeometry().setFromPoints([
                        malhasNos[origem].position,
                        malhasNos[destino].position
                    ]);
                    const linhaCaminho = new THREE.Line(geometriaCaminho, new THREE.LineBasicMaterial({ color: 0x00ff00 }));
                    cena.add(linhaCaminho);
                });

                // Atualizar visibilidade das etiquetas de arestas
                Object.keys(etiquetasArestas).forEach(chaveAresta => {
                    if (arestasCaminho.has(chaveAresta)) {
                        etiquetasArestas[chaveAresta].visible = true; // Mostrar etiquetas de arestas no caminho
                    } else {
                        etiquetasArestas[chaveAresta].visible = false; // Ocultar etiquetas de arestas que não estão no caminho
                    }
                });

                // Atualizar visibilidade das etiquetas de nós
                Object.keys(etiquetasNos).forEach(idNo => {
                    if (nosCaminho.has(idNo)) {
                        etiquetasNos[idNo].visible = true; // Mostrar etiquetas de nós no caminho
                    } else {
                        etiquetasNos[idNo].visible = false; // Ocultar etiquetas de nós que não estão no caminho
                    }
                });

                // Exibir as informações do caminho (nomes das estrelas e distâncias)
                data.path_info.forEach(info => {
                    console.log(`De: ${info.source} para: ${info.target}, Distância: ${info.distance} anos-luz`);
                    // Opcionalmente adicionar etiquetas de texto à cena
                });
            })
            .catch(error => console.error('Erro ao buscar o caminho mais curto:', error));
        }

        // Lidar com eventos de clique do mouse para selecionar nós
        window.addEventListener('click', (event) => {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersectados = raycaster.intersectObjects(Object.values(malhasNos));

            if (intersectados.length > 0) {
                const noSelecionado = intersectados[0].object.userData.id;

                if (nosSelecionados.length === 0) {
                    nosSelecionados.push(noSelecionado);
                } else if (nosSelecionados.length === 1) {
                    nosSelecionados.push(noSelecionado);
                    encontrarCaminhoMaisCurto(nosSelecionados[0], nosSelecionados[1]);
                    nosSelecionados = [];
                } else {
                    nosSelecionados = [noSelecionado];
                }
            }
        });

        // Lidar com eventos de teclado para resetar os nós selecionados
        window.addEventListener('keydown', (event) => {
            if (event.key === 'Escape') {
                // Redefinir nós selecionados
                nosSelecionados = [];
                
                // Mostrar todos os nós e arestas
                Object.keys(malhasNos).forEach(idNo => {
                    malhasNos[idNo].visible = true;
                });
                Object.keys(linhasArestas).forEach(chaveAresta => {
                    linhasArestas[chaveAresta].visible = true;
                    const etiquetaAresta = etiquetasArestas[chaveAresta];
                    if (etiquetaAresta) {
                        etiquetaAresta.visible = true;
                    }
                });

                // Atualizar visibilidade das etiquetas de nós
                Object.keys(etiquetasNos).forEach(idNo => {
                    etiquetasNos[idNo].visible = true;
                });

                // Remover arestas do caminho anteriormente encontrado, se necessário
                cena.children.forEach(child => {
                    if (child instanceof THREE.Line && child.material.color.equals(new THREE.Color(0x00ff00))) {
                        cena.remove(child);
                    }
                });

                console.log('Nós selecionados resetados');
            }
        });

        function animar() {
            requestAnimationFrame(animar);
            controles.update();
            renderizador.render(cena, camera);
        }

        animar();

        // Buscar e adicionar dados do grafo
        fetch('/graph-data')
            .then(response => response.json())
            .then(data => {
                if (data.error) {
                    console.error(data.error);
                    return;
                }
                adicionarDadosGrafo(data.nodes, data.edges);
            })
            .catch(error => console.error('Erro ao buscar dados do grafo:', error));

        // Lidar com redimensionamento da janela
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderizador.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
